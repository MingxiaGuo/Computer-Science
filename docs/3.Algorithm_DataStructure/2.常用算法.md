https://www.hello-algo.com/chapter_data_structure/

# 1 Sorting Algorithms

## Selection sort

## Bubble sort

## Insertion sort

## Heap sort

## Merge sort

## Quick sort

# 2 Search Algorithms
## 2.1 List Search Algorithms

### Linear Search

### Binary Search 二分查找
寻找分割点
二分查找是一个高效查找方法，适合用于有序数组或具有一定规律的数据结构中，二分查找核心思想是每次将搜索区间缩小一半，来快速逼近答案
三问三答形式思考：
1。 对于每个中间点mid，我们应该如何处理
2. 如何调整左右指针left和right以缩小搜索范围
3. 在什么条件下可以直接返回答案

二分查找问题三要素：
1.mid指针及所有对应元素mid_val
2. 左右指针left和right及其变化
3. 返回答案的条件

## 2.2 Graph Search Algorithms

### Breadth-First Search 广度优先搜索
适合用于搜索最短路径或进行层级遍历问题

### Depth-First Search 深度优先搜索
深度优先搜索是一种遍历或搜索图，树结构的算法，用于解决全路径，连通性等问题


### Bellman-Ford

### Dijkstra's Algorithms

### A* Algorithms

# 分治算法

归并排序

# 回溯算法

适用于子集与组合问题，涉及生成所有子集，组合和排列。

回溯算法通常并不显式地对问题进行拆解，而是将求解问题看作一系列决策步骤，通过试探和剪枝，搜索所有可能的解。

回溯算法（backtracking algorithm）是一种**通过穷举来解决问题**的方法，它的核心思想是从一个初始状态出发，**暴力搜索**所有可能的解决方案，当遇到正确的解则将其记录，直到找到解或者尝试了所有可能的选择都无法找到解为止。

回溯算法通常采用“深度优先搜索”来遍历解空间。在“二叉树”章节中，我们提到前序、中序和后序遍历都属于深度优先搜索

**之所以称之为回溯算法，是因为该算法在搜索解空间时会采用“尝试”与“回退”的策略****回退并不仅仅包括函数返回**。
# 3. 动态规划

动态规划常用来求解最优化问题，它们不仅包含重叠子问题，还具有另外两大特性：最优子结构、无后效性(**给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关**)。
动态规划（dynamic programming）是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。


将小问题的解汇集成大问题的答案
**原问题的解可以由子问题的解构建得来**

，**递归地将一个较大问题拆解为两个较小问题的和**，直至到达最小子问题
**动态规划是一种“从底至顶”的方法**
根据以上内容，我们可以总结出动态规划的常用术语。
* 将数组 `dp` 称为 dp 表，dp[i]表示状态i对应子问题的解。
- 将最小子问题对应的状态（第1阶和第2阶楼梯）称为初始状态。
- 将递推公式dp[i]=dp[i-1]+dp[i-2]称为状态转移方程。

背包问题：0-1背包问题(**每个物品只能选择1次**)，完全背包问题(**每个物品可以重复选取**)，多重背包问题


----
子问题分解是一种通用的算法思路，在分治、动态规划、回溯中的侧重点不同。

- 分治算法递归地将原问题划分为**多个相互独立的子问题**，直至最小子问题，并在回溯中合并子问题的解，最终得到原问题的解。
- 动态规划也对问题进行递归分解，但与分治算法的主要区别是，动态规划中的**子问题是相互依赖**的，在**分解过程中会出现许多重叠子问题**。
- 回溯算法在尝试和回退中**穷举**所有可能的解，并通过**剪枝**避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以将每个决策步骤之前的子序列看作一个子问题。
# 4. 贪心算法

# 5. 字符串匹配算法


# 前缀和算法

用空间换时间的算法，
前缀和是指某序列的前n项和，可以把它理解为数学上的数列的前n项和，而差分可以看成前缀和的逆运算。合理的使用前缀和与差分，可以将某些复杂的问题简单化。

![](https://pic4.zhimg.com/80/v2-fc35e65946ef19503373b70194bce193_1440w.webp)

#  滑动窗口算法
解决优化子数组和子字符串相关问题
滑动窗口核心思想是在一个可变大小的窗口中维护一些信息，并通过窗口移动来缩小问题范围。

通过三问三答形式思考：
1，对于每一个右指针right所指元素ch，做什么操作？
2. 什么时候要令左指针left右移，left对应元素做什么操作？循环不变量
3. 什么时候进行ans的更新

【满足XX（计算结果，出现结果，同时包含）条件 】的 【最长/最短 】的 【连续】的【子字符串/子数组/子序列】

例如：长度最小的子数组

滑动窗口是[双指针算法](https://zhida.zhihu.com/search?q=%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95&zhida_source=entity&is_preview=1)的一种，利用**双指针**在数组**单一方向**滑动，形成一个子区间，对子区间进行剪枝，最终得出**满足条件**的解。

记住模板：一容（window），二变（left，right），三扩（right右移），[四缩](https://zhida.zhihu.com/search?q=%E5%9B%9B%E7%BC%A9&zhida_source=entity&is_preview=1)- （left右移）
- 思路：俩个条件（[left右滑条件](https://zhida.zhihu.com/search?q=left%E5%8F%B3%E6%BB%91%E6%9D%A1%E4%BB%B6&zhida_source=entity&is_preview=1)
，是否更新结果值条件），俩个变化（right右滑动变量变化，[left右滑动变量](https://zhida.zhihu.com/search?q=left%E5%8F%B3%E6%BB%91%E5%8A%A8%E5%8F%98%E9%87%8F&zhida_source=entity&is_preview=1)- 变化）
- 易错点：例如第二题每次滑动需要更新的变量很多，稍有不慎就会少更新某个变量，每次对照开始声明的变量可以万无一失

这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。

```go
left := 0
right := 0
for right < len(s){
    // 增大窗口
    window = append(window, s[right])
    right++
    
    for window needs shrink{
        // 缩小窗口
        window.remove(s[left]) // 伪码
        left++
    }
}
```


题单】滑动窗口与双指针（定长/不定长/单序列/双序列/三指针） https://leetcode.cn/circle/discuss/0viNMK/


# 双指针算法：高效遍历与查找

适用于数组和字符串遍历与查找问题，尤其是在需要高效处理对称性或前后关系时

# 堆：寻找top-k元素

适合解决top-k问题的数据结构，通过维护一个k大小的堆，可以高效的找到数组中的前k个最大或最小元素。

# 递归

递归算法允许函数调用自身来解决问题，常用于解决可以分解为相似子问题的问题
1. 直接递归：函数自身调用自身，直到满足基本情况
2. 分治递归：将问题分解为多个小问题，递归解决这些小问题，然后合并结束
3. 回溯递归：在搜索解空间时使用递归，如果当前路径不是解的一部分，则回溯到上一步
4. 动态规划递归：结合动态规划的思想。使用递归和记忆化来优化重复计算。
# 3. Clustering Algorithms

## k-means

# Data Compression

# Security

