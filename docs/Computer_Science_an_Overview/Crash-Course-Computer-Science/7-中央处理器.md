# 7. The Central Process Unit-CPU中央处理器

> 用ALU和寄存器做CPU



我们已经做了一个算计逻辑单元ALU，输入二进制它会执行计算，还做了两种内存：寄存器(很小的一块内存，能存一个值)；RAM(一大块内存，能在不同地址存大量数字)，现在把这些放在一起，组建计算机的“心脏”——CPU。

CPU负责执行程序，程序由一个个指令(Instruction)组成,它们指示计算机要做什么，CPU会让ALU进行数学运算，也可能是内存指令，CPU会和内存通信，然后读/写值，CPU里有很多组件。我们把重点放在功能，而不是一根线具体怎么连，当我们用一条线连接两个组件时，这条线只是所有必须线路的一个抽象，这种高层次视角叫“微体系架构(microarchitecture)”

取1个RAM(为了简单，它只有16个位置，每个位置存8位)，4个8位寄存器A,B,C,D(寄存器用来临时存数据和操作数据)， 数据和程序都可以存在内存里。给CPU支持的所有指令分配一个ID。在这个假设的例子中，我们用前四位存“操作代码”(operation code),简称操作码opcode，后四位代表数据来自哪里，可以是寄存器或内存地址。

![](../assets/7-指令表.png)

我们还需要两个寄存器来完成cpu，1.一个寄存器追踪程序运行到哪里了，我们叫它“指令地址寄存器”(instruction address register),存当前指令的内存地址；2.另一个寄存器存当前指令，叫“指令寄存器”。当启动计算机时，所有寄存器从0开始。举例：我们在RAM里放一个程序，过一遍CPU的第一个阶段“取指令阶段”(fetch phase)——负责拿到指令。

![](../assets/7-fetch-phase.png)

首先，将“指令地址寄存器”连到ＲAＭ,寄存器的值为０，因此RAM返回地址0的值，00101110会复制到"指令寄存器“里，现在就拿到指令了。

![](../assets/7-fetch-phase-2.png)

要弄清是什么指令，才能执行(execute)，这是解码过程(Decode Phase)。根据指令表前4位0010是LOAD A指令，意思是把RAM的值放入寄存器A，后4位11110是RAM的地址，转成十进制是14。接下来指令由“控制单元”进行解码，就像之前的所有东西“控制单元”也是逻辑门组成的。比如为了识别LOAD指令，需要一个电路，检查操作码是不是0010，可以用很少的门电路实现。

![](../assets/7-decode-phase.png)

现在知道是什么指令，就可以开始执行了，开始“执行阶段”(Execuye Phase)。用“检查是否LOAD_A指令的电路”可以打开RAM的“允许读取线”，把地址14传过去，RAM拿到值00000011，十进制是3.因为是LOAD_A指令，我们想把这个值只放到寄存器A，其他寄存器不受影响，所以需要一根线连到4额寄存器，用“检查是否LOAD_A指令的电路”启用寄存器A的“允许写入线”，就成功了，把RAM地址14的值放到了寄存器Ａ。指令完成后我们可以关掉所有线路去拿下一条指令。”指令地址寄存器“＋１，执行阶段就此结束。

![](../assets/7-execute-phase.png)

LOAD_A只是ＣPU可以执行的各种指令之一，不同指令由不同逻辑电路解码，这些逻辑电路会配置CPU内的组件来执行对应操作。具体分析这些解码电路很繁琐，干脆把”控制单元“包成一个整体，简洁一些，就是一层新的抽象。控制单元像管弦乐指挥，指挥CPU的所有组件。

![](../assets/7-control-unit.png)

取指令-->解码-->执行 完成后，可以再来一次，从取指令开始，RAM返回地址1里的值：00011111，到解码阶段，0001是LOAD_B指令，从RAM里把一个值复制到寄存器B，这次内存地址是1111，十进制是15.现在到执行阶段，控制单元叫RAM读地址15，并配置寄存器B接收数据，成功，我们把

* 拼个CPU出来
* CPU怎么执行指令
* RAM+寄存器+ALU做个CPU
* 解释“取指令->解释->执行”这个循环
* 时钟是什么，时钟速度和赫兹
* 超频提升性能，降频省电