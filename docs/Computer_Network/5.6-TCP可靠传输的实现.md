## 5.6 

TCP 可靠通信的特征：:
1、TCP 连接的每一端都必须设有两个窗口一个发送窗口和一个接收窗口。
2、TCP 的可靠传输机制用字节的序号进行控制TCP 确认都是基于字节序号而，不是基于报文段。 
3、TCP 两端的四个窗口经常处于动态变化之中。
4、TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。
为讲述方便，我们假定数据传输只在一个方向进行。

### 5.6.1 以字节为单位的滑动窗口协议

TCP滑动窗口是以字节为单位的。 
1、发送窗口可连续发送的字节范围，通常只是发送缓存的一部分；在没有收到对方确认下，发送可连续把窗口中的数据都发送出去。凡是已经发送过的数据，在未收到确认之前必须暂时保留，以便超时重传。

⑴、发送窗口的后沿后面部分表示已经发送且已接收到确认；
	发送窗口的后沿的两种变化情况 
	①.前移	收到新的确认；
	②.不动	没有收到新的确认，并且对方通知的窗口大小没变；
收到新的确认，但对方通知的窗口大小缩小了使得前沿正好不动；
⑵、发送窗口的前沿前面部分表示不允许发送；
⑶、前沿与后沿共同确认发送窗口的位置；
⑷、后沿不可能后移，前沿不断前移，也可能不动；
⑸、TCP不赞成前沿向后回缩（由于B通知的窗口大小缩小了而需要前沿回缩）；
⑹、描述发送窗口状态需三个指针：P1、P2、P3；
①.小于P1的表示已发送并已接收到确认的部分。
②.大于P3的是不允许发送的部分。
③.P3－P1=发送方A的发送窗口
④.P2－P1=已发送但尚未收到确认的字节数。
⑤.P3－P2=允许发送但尚未发送的字节数。
2、发送缓存用来存放以下数据： 
①.发送应用程序传给发送方TCP；准备发送的数据
②.TCP已发送但尚未收到确认的数据。 
发送缓存与发送窗口后沿重合。 
3、接收窗口可连续接收的字节范围，通常只是接收缓存的一部分。
4、接收缓存用来暂时存放以下数据： 
①.按序到达的，但尚未被接收应用程序读取的数据；
②.不按序到达的数据；

【例题5.2】TCP可靠传输的具体实现的实例活动窗口协议简介： 
①.假设：某一时刻A的发送窗口和B的接收窗口如图5-16所示，接收窗口和发送窗口大小为20B不变；由于B只能对按序收到的数据中的最高序号给出确认，此时虽然正确地收到32和33号报文，但没收到31号报文，所以B发送的确认报文中的确认号为31（即期望收到31号报文），32和33号报文存储在B的缓存中等待31号报文；

②.A收到确认号为31号的确认报文后停止发42号报文而重传缓存中的31号报文；重传后继续发送42以后的报文直至发送窗口前沿； 
③.当B正确地收到31号报文后把31—33号报文交给主机并从缓存中删除，然后发送确认号为34号的新确认报文；同时B的接收窗口后沿移到34，前沿移到54并继续接收报文； 
④.A收到确认号为34号的新确认报文后把接收窗口后沿移到34，前沿移到54，从发送缓存中删除33号以前的报文，并继续发送42以后未发送的报文直至发送窗口前沿；（如图5-17所示）

⑤.若A的发送窗口已满（即可用窗口为0）就停止发送数据，等待新的确认（如图5-18所示）；若此后收到新的确认（假设确认号为41），则重传41号报文，并把接收窗口后沿移到41，前沿移到61，从发送缓存中删除40号以前的报文，并继续发送53以后未发送的报文直至发送窗口前沿；如此循环直至B接收完数据；

5、我们应注意三点 
   	①.发送窗口并不总是与接收方接收的窗口一样大；
②.TCP标准并未规定对不按序到达的数据如何处理，通常做法是临时存在接收窗口，等缺少的字节到达后再按序交付上层应用程序；
③.TCP要求接收方必须有积累确认功能，以减少传输开销。接收方有数据要发送时可捎带确认。但累积的时间不应该超过0.5秒；

### 5.6.2 超时重传时间的选择

TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。TCP超时计时器的超时重传时间究竟应设置多大呢？ 
1、TCP采用了一种自适应算法  
TCP保留了RTT的一个加权平均往返时间RTTs，第一次测量的RTT样本值作为RTTs的初始值，以后每测到一个RTT样本，就按下式重新计算一次RTTs：

式中，0 £ a < 1。若 a 很接近于零，表示 RTT 值更新较慢。若选择 a 接近于 1，则表示 RTT 值更新较快。RFC 2988 推荐的 a 值为 1/8，即 0.125。 
超时重传时间RTO略大于RTTs，使用下式计算：

RTTD是 RTT 的偏差的加权平均值第一次测量RTTD为RTT样本值的一半，以后按下式计算：

b 是个小于 1 的系数，其推荐值是 1/4，即 0.25
2、Karn方法和改进的Karn方法
问题若重传时间到了，但仍未收到确认，于是重传报文，经过一段时间后，收到确认，此时如何判断此确认报文是对先前发送的报文确认，还是对以后重传报文的确认？方法如下：
⑴、Karn的方法在计算RTTs时，只要报文重传了，就不采用其往返时间样本；
这样得到的加权平均RTTs和RTO就比较准确。但这引起新的问题，即若报文段时延增大了很多，超时重传时间无法更新，使重传次数增多。
⑵、改进的Karn方法报文段每重传一次，把RTO增大一些。
新的 RTO = g ´（旧的RTO) {系数 g 的典型值是 2}

### 5.6.3 选择确认 SACK



1、问题的提出接收方收到了和前面的字节流不连续的两个字节块，这些字节的序号都在接收窗口之内，接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方只发中间未收到的数据块而不要再重复发送这些已收到的数据，如何实现？

2、问题的解决办法RFC2018的规定：
⑴、如果要使用选择确认，那么双方必须都事先商定好在建立 TCP 连接时，就要在TCP 首部的选项中加上“允许 SACK”的选项。
⑵、原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。
⑶、由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明 4 个字节块的边界信息，32B，还需一个字节指明是SACK选项，一个字节指明这个选项占多少字节；
⑷、SACK文档并未指明发送方应当怎样响应SACK，因此，大多数的实现还是重传所有未被确认的数据块。
