# ICMP

- ICMP相当于网络世界的侦察兵。我讲了两种类型的ICMP报文，一种是主动探查的查询报文，一种异常报告的差错报文；
- ping使用查询报文，Traceroute使用差错报文。

### 4.4.1 ICMP的简介

ICMP: Internet **Control** Message Protocol 互联网**控制**报文协议

* ICMP的作用 
  * 更有效地转发IP数据报； 
  * 提高成功交付的机会；

* ICMP的特点 
  * ICMP是网络层协议，它的报文不是直接传送给数据链路层，而是要封装成IP数据报后传送给数据链路层，目的是解决IP协议中可能出现的不可靠问题。
  * ICMP差错报告采用“路由器—源主机”模式即一旦路由器发现数据报传输错误，将通知源主机，通知报文独立选路。引入控制报文后，该模式被打破。
  
* ICMP报文的格式 

  ![23aecf653d60dd94b7c5c6dc21ca21ff](https://static001.geekbang.org/resource/image/23/ff/23aecf653d60dd94b7c5c6dc21ca21ff.jpg)

### 4.4.2 ICMP报文的种类

**ICMP查询报文**：2种

* **回送请求和回答报文**：最常用。ICMP回送请求报文是主机或者路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或者路由器发送ICMP回答报文，目的是测试目的站是否可达以及了解其有关状态。**主动请求类型代码为8，主动请求的应答类型代码为0**
* 时间戳（chuō）请求与回答报文：ICMP时间戳请求报文是请某个主机或者路由器回答当前日期和时间，目的是进行时钟同步和测量时间 

**ICMP差错报告报文**：

* ICMP的5种差错报告报文 
  * ①.**终点不可达报文**：类型代码为3；当路由器或者主机不能交付数据报时，就向源点发送终点不可达报文。网络不可达代码为0，主机不可达代码为1，协议不可达代码为2，端口不可达代码为3，需要进行分片但设置了不分片位代码为4。
  * ②.源点抑制报文：类型代码为4；当路由器或主机由于阻塞而丢弃数据时，就向源点发送源点抑制报文，使源点减慢数据发送速率。
  * ③.超时报文：类型代码为11；当路由器收到生存时间为零的数据报时，除丢弃该数据报时，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到数据报全部数据报片时，就将已收到的数据报片丢弃，并向源点发送超时数据报文。
  * ④.参数问题报文：当路由器或者目的主机收到的数据报首部有字段值不正确时，丢弃该数据报，并向源点发送参数问题报文。
  * ⑤.改变路由（重定向）报文：类型代码为5；路由器把改变路由报文发送给主机，通知主机下次将数据报发送给别的路由器。
* ICMP差错报告报文的形成方法  所有ICMP首部包括类型、代码与检验和三部分共4个字节的信息字段。ICMP差错报文的数据字段格式相同，由收到的需要差错报告的数据报首部及其数据部分前8个字节组成。
* 不应发送ICMP差错报文的几种情况：
  ①.对ICMP差错报告报文不再发送ICMP差错报告报文；
  ②.对第一分片以后的所有数据报分片不发送ICMP差错报告报文；
  ③.对多播地址的数据报都不发送ICMP差错报告报文；
  ④.对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报文；

### 4.4.3 ICMP应用举例

【例题4.12】PING程序 使用ICMP回送请求与回送回答报文测试主机之间的连通性；

【例题4.13】traceroute程序 源主机依次发送TTL为1，2，…，的数据报，直到有一个数据报刚刚到达目的主机时，TTL为1，主机不转发数据报，TTL值也不减1。因为数据报封装着无法交付的UDP用户数据报，故目的主机向源主机发送目的不可达的差错控制报文。这其间的每个路由器都因数据报TTL为0发送超时控制报文。对于每个TTL值源主机发送三次同样数据报。

#### ping

ping是基于ICMP协议工作的。常用的**ping就是查询报文，是一种主动请求，并且获得主动应答的ICMP协议。**所以，ping发的包也是符合ICMP协议格式的，只不过它在后面增加了自己的格式。

对ping的主动请求，进行网络抓包，称为**ICMP ECHO REQUEST。**同理主动请求的回复，称为**ICMP ECHO REPLY**。比起原生的ICMP，这里面多了两个字段，一个是**标识符**。这个很好理解，你派出去两队侦查兵，一队是侦查战况的，一队是去查找水源的，要有个标识才能区分。另一个是**序号**，你派出去的侦查兵，都要编个号。如果派出去10个，回来10个，就说明前方战况不错；如果派出去10个，回来2个，说明情况可能不妙。

在选项数据中，ping还会存放发送请求的时间值，来计算往返时间，说明路程的长短。

**ping：查询报文类型的使用**：![e5270427819fc51c88e81a5c1cc4b8fc](https://static001.geekbang.org/resource/image/e5/fc/e5270427819fc51c88e81a5c1cc4b8fc.jpg)

假定主机A的IP地址是192.168.1.1，主机B的IP地址是192.168.1.2，它们都在同一个子网。那当你在主机A上运行“ping 192.168.1.2”后，会发生什么呢?

ping命令执行的时候，源主机首先会构建一个ICMP请求数据包，ICMP数据包内包含多个字段。最重要的是两个，第一个是**类型字段**，对于请求数据包而言该字段为 8；另外一个是**顺序号**，主要用于区分连续ping的时候发出的多个数据包。每发出一个请求数据包，顺序号会自动加1。为了能够计算往返时间RTT，它会在报文的数据部分插入发送时间。

然后，由ICMP协议将这个数据包连同地址192.168.1.2一起交给IP层。IP层将以192.168.1.2作为目的地址，本机IP地址作为源地址，加上一些其他控制信息，构建一个IP数据包。

接下来，需要加入MAC头。如果在本节ARP映射表中查找出IP地址192.168.1.2所对应的MAC地址，则可以直接使用；如果没有，则需要发送ARP协议查询MAC地址，获得MAC地址后，由数据链路层构建一个数据帧，目的地址是IP层传过来的MAC地址，源地址则是本机的MAC地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。

主机B收到这个数据帧后，先检查它的目的MAC地址，并和本机的MAC地址对比，如符合，则接收，否则就丢弃。接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP层。同样，IP层检查后，将有用的信息提取后交给ICMP协议。

主机B会构建一个 ICMP 应答包，应答数据包的类型字段为 0，顺序号为接收到的请求数据包中的顺序号，然后再发送出去给主机A。

在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 应答包，则说明目标主机可达。此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。

当然这只是最简单的，同一个局域网里面的情况。如果跨网段的话，还会涉及网关的转发、路由器的转发等等。但是对于ICMP的头来讲，是没什么影响的。会影响的是根据目标IP地址，选择路由的下一跳，还有每经过一个路由器到达一个新的局域网，需要换MAC头里面的MAC地址。这个过程后面几节会详细描述，这里暂时不多说。

如果在自己的可控范围之内，当遇到网络不通的问题的时候，除了直接ping目标的IP地址之外，还应该有一个清晰的网络拓扑图。并且从理论上来讲，应该要清楚地知道一个网络包从源地址到目标地址都需要经过哪些设备，然后逐个ping中间的这些设备或者机器。如果可能的话，在这些关键点，通过tcpdump -i eth0 icmp，查看包有没有到达某个点，回复的包到达了哪个点，可以更加容易推断出错的位置。

经常会遇到一个问题，如果不在我们的控制范围内，很多中间设备都是禁止ping的，但是ping不通不代表网络不通。这个时候就要使用telnet，通过其他协议来测试网络是否通，这个就不在本篇的讲述范围了。

说了这么多，你应该可以看出ping这个程序是使用了ICMP里面的ECHO REQUEST和ECHO REPLY类型的。

#### traceroute

Traceroute：差错报文类型的使用

那其他的类型呢？是不是只有真正遇到错误的时候，才能收到呢？那也不是，有一个程序Traceroute，是个“大骗子”。它会使用ICMP的规则，故意制造一些能够产生错误的场景。

所以，**Traceroute的第一个作用就是故意设置特殊的TTL，来追踪去往目的地时沿途经过的路由器**。Traceroute的参数指向某个目的IP地址，它会发送一个UDP的数据包。将TTL设置成1，也就是说一旦遇到一个路由器或者一个关卡，就表示它“牺牲”了。

如果中间的路由器不止一个，当然碰到第一个就“牺牲”。于是，返回一个ICMP包，也就是网络差错包，类型是时间超时。那大军前行就带一顿饭，试一试走多远会被饿死，然后找个哨探回来报告，那我就知道大军只带一顿饭能走多远了。

接下来，将TTL设置为2。第一关过了，第二关就“牺牲”了，那我就知道第二关有多远。如此反复，直到到达目的主机。这样，Traceroute就拿到了所有的路由器IP。当然，有的路由器压根不会回这个ICMP。这也是Traceroute一个公网的地址，看不到中间路由的原因。

怎么知道UDP有没有到达目的主机呢？Traceroute程序会发送一份UDP数据报给目的主机，但它会选择一个不可能的值作为UDP端口号（大于30000）。当该数据报到达时，将使目的主机的 UDP模块产生一份“端口不可达”错误ICMP报文。如果数据报没有到达，则可能是超时。

这就相当于故意派人去西天如来那里去请一本《道德经》，结果人家信佛不信道，消息就会被打出来。被打的消息传回来，你就知道西天是能够到达的。为什么不去取《心经》呢？因为UDP是无连接的。也就是说这人一派出去，你就得不到任何音信。你无法区别到底是半路走丢了，还是真的信佛遁入空门了，只有让人家打出来，你才会得到消息。

**Traceroute还有一个作用是故意设置不分片，从而确定路径的MTU。**要做的工作首先是发送分组，并设置“不分片”标志。发送的第一个分组的长度正好与出口MTU相等。如果中间遇到窄的关口会被卡住，会发送ICMP网络差错包，类型为“需要进行分片但设置了不分片位”。其实，这是人家故意的好吧，每次收到ICMP“不能分片”差错时就减小分组的长度，直到到达目标主机。
