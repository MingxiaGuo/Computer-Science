# 因特网的路由选择协议

**网关Gateway 往往是一个路由器，是一个三层转发的设备**。三层设备就是把MAC头和IP头都取下来，然后根据里面的内容，看看接下来把包往哪里转发的设备。

Gateway的地址一定是和源IP地址是一个网段的。往往不是第一个，就是第二个。例如192.168.1.0/24这个网段，Gateway往往会是192.168.1.1/24或者192.168.1.2/24。

很多情况下，人们把网关就叫作路由器。其实不完全准确，而另一种比喻更加恰当：**路由器是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的IP地址都和局域网的IP地址相同的网段，每只手都是它握住的那个局域网的网关。**任何一个想发往其他局域网的包，都会到达其中一只手，被拿进来，拿下MAC头和IP头，看看，根据自己的路由算法，选择另一只手，加上IP头和MAC头，然后扔出去。

MAC地址是一个局域网内才有效的地址。因而，MAC地址只要过网关，就必定会改变，因为已经换了局域网。两者主要的区别在于IP地址是否改变。不改变IP地址的网关，我们称为**转发网关；**改变IP地址的网关，我们称为**NAT网关**。

上一节我们描述的是一个相对简单的情形。出了网关之后，只有一条路可以走。但是，网络世界复杂得多，一旦出了网关，会面临着很多路由器，有很多条道路可以选。如何选择一个更快速的道路求取真经呢？

路由器就是一台网络设备，它有多张网卡。当一个入口的网络包送到路由器时，它会根据一个本地的转发信息库，来决定如何正确地转发流量。这个转发信息库通常被称为**路由表**。



### 4.5.1基本概念

理想的路由算法：

* ①.算法必须是正确的和完整的：分组能到达目的主机；
* ②.算法在设计上应简单：网络通讯量尽可能小；
* ③.算法应具有自适应性：应能适应通信量和网络拓扑的变化；
* ④.算法应具有稳定性：算法收敛性好；
* ⑤.算法应该是公平的：除优先级高的用户外，算法对所有用户都是公平的；
* ⑥.算法应是最佳的：所谓“最佳”只是对于某一特定要求较为合理 

路由选择的复杂性高是因为 

* ①.它是使网络中的所有结点共同协调工作的结果。
* ②.路由选择的环境往往不断变化。

依据算法能否随网络的通信量和拓扑自适应调整变化划分：

* ①.静态路由：非自适应路由选择，简单，适合小型网络
* ②.动态路由：自适应路由选择，复杂，开销大，适合大型网络

分层次的路由选择协议：因特网主要采用动态的分布式路由选择协议，

* 由于以下两个原因，因特网采用分层次的路由选择协议。

  * ①.因特网规模太大有几百万个路由器互连。如果让所有路由器知道所有网络怎么样到达，则这种路由表将非常大，处理起来太花时间。所有路由器之间交换信息所需带宽，就会使因特网通信链路饱和。

  * ②.许多单位不愿意外界了解自己单位网路的布局细节，但同时希望连接Internet为此，因特网将整个互联网划分为许多小的自治系统，记为AS ；AS是单一技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度量，以确定分组在该AS内的路由，同时还使用一种AS之间的路由选择协议，用以确定分组在AS之间的路由；即：一个AS内部可使用多种路由协议和度量，但对其它AS表现出的是一个单一的和一致的路由选择策略；

分层次的路由选择协议：

* 内部网关协议IGP (Interior Gateway Protocol) ：一个AS内使用的路由选择协议，如：

  * RIP（Routing information Protocol路由信息协议）、

  * OSPF（Open Shortest Path First开放式最短路径优先）等；


* 外部网关协议EGP (External Gateway Protocol) ：不同自治系统之间使用的路由选择协议，如：
  * BGP（Border Gateway Protocol,边界网关协议）等；

对于大的AS，还可将所有网络再划分成区域网和主干网。

### 4.5.2 内部网关协议 RIP

4.5.2、内部网关协议之一路由信息协议（RIP）
1、RIP的工作原理：
⑴、分布式路由选择协议就是每一个路由器都要不断地和其它路由器交换信息，交换信息的三个要点：①.和哪些路由器交换信息；②.交换什么信息；③.什么时候交换信息；
⑵、RIP的距离概念从一个路由器到直连网络的距离定义为1（也可定义为0，不常用），从一路由器到非直连网络的距离定义为所经过的路由器数加1，从网络A经N个路由器到达网络B的距离为N+1；
RIP协议的距离也称为跳数，RIP允许一条路径最多只能包含15个路由器。因此距离为16即表示不可达。故RIP只适用于小型互联网。 
⑶、RIP的工作原理简述最大的优点就是简单；
RIP是一种分布式距离向量路由选择协议，RIP协议要求网络中每一个路由器都要维护从它自己到每一个目标网络的距离记录，形成距离向量，距离向量的集合称之为“路由表”（路由表的最主要信息：目的网络、最短距离、下一跳）；
路由器开始工作时，只知道自己直连的网络距离。通过与相邻路由器的不断交换信息，最终都会知道到达本AS中任何一个网络的最短距离和下一跳路由器地址。
RIP选择一条具有最短距离的路由，且不能在两个网络之间同时使用多条路由。
⑵、RIP协议的三个要点：
①.仅和相邻路由器交换信息；
②.交换的信息是当前路由器所知道的全部信息，即路由表；
③.按固定时间间隔交换信息，例如30秒一次；

2、距离向量算法：
对每一个相邻路由器发过来的RIP报文，进行以下步骤： 
⑴、对地址X的相邻路由器发过来的RIP报文，先修改此报文中所有项目把下一跳字段中地址都改为X，并把所有距离字段值加1；
⑵、针对修改后的RIP报文中每一表项进行以下操作
若：原来的路由表中没有目的网络N，则把该项目添加到路由表中；
否则：查看原表项的下一跳路由地址是否为X：
若：下一跳是X，则把收到的表项替换原表项（取用最新消息）；
否则：比较距离大小：
若收到的表项距离小于原表项的距离，则更新，
否则什么也不做；
⑶、若3分钟还没收到相邻路由器更新的路由表，则视该路由器不可达，把以此路由器为下一跳的表项距离置16； 
⑷、返回；
【例题4.14】已知路由器R1，有表Ra所示的路由表。现收到相邻路由器R2发来的更新信息如表Rb所示，试写出R1更新后的路由表
表Ra	表Rb	结果R1a
目的网络	下一跳	距离	目的网络	下一跳	距离	目的网络	下一跳	距离
Net2	R4	3	Net1	R1	3	Net1	R4	4
Net3	R5	4	Net2	R2	4	Net2	R4	5
…	…	…	Net3	直接交付	1	Net3	R4	2
…	…	…	…	…	…	…	…	…
RIP协议让一个自治系统中的所有路由器都和自己相邻路由器定期交换路由信息，并不断更新其路由表，使得从每一个路由器到每一目的网络的路由都最短

3、RIP协议报文格式：
RIP2较RIP1协议本身并无多大变化，但性能上有改进；RIP2使用运输层的用数据报UDP进行传送。

命令字段指出报文的意义，比如：1表示请求路由信息，2表示对请求路由信息的响应或更新报文；
必为0字段为凑足4字节；
地址族标记（地址类别）字段标示所用的地址协议，比如:2表示IP地址
路由标记字段填入自治系统号ASN；其后便是路由表项（如下所示）
表项头部信息（4B）	目的网络（8B）	下一跳（4B）	距离（4B）
地址族标记(2B)	路由标记(2B)	IP地址	子网掩码	下一跳路由器地址	到此网络的距离
2	65535	192.168.6.3	255.255.255.0	168.62.3.1	3
…	…	…	…	…	…
RIP2报文中的路由部分由若干条路由信息组成，每一条路由信息长20B，最多路由信息不超过25条，RIP报文的最大长度=4+20*25=504B，一个RIP报文不够可再用一个或多个RIP报文；
RIP2还具有简单鉴别功能。若使用该功能，则将原来的第一个路由的20字节用作鉴别，此时地址族标识符全置1，路由标记写入鉴别类型，剩下16B鉴别数据。

4、RIP 协议的优缺点 
⑴、最大的优点实现简单，开销较小。 
⑵、缺点之一好消息传播快，坏消息传播慢（典型特点），即：当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器；
⑶、缺点之二RIP 限制了网络的规模：可使用的最大距离为 15（16 表示不可达）
⑷、缺点之三网络规模大，开销就大：路由器之间交换的信息是完整路由表；
【例题4.14】好消息传播快，坏消息传播慢的实例分析：
下图说明：	 表示达到网络1的距离为16，直接到达；
 表示达到网络1的距离为3，下一跳为R2；

 

### 4.5.3 内部网关协议 OSPF

4.5.3、内部网关协议之二开放式最短路径优先（OSPF）
1、OSPF协议的特点：
事实上，所有自治系统内部使用的路由选择协议都是要寻找一条最短的路径；
OSPF最主要的特征就是使用分布式链路状态路由选择协议，其特点是 
①.使用洪泛法向本自治系统中的所有路由器发信息即：每个路由器向所有相邻路由器发送信息，而每一个相邻路由器又将此信息发送给与他所有相邻路由器（除刚发来信息的路由器）。
②.发送的信息就是与相路由器相邻的所有路由器的链路状态。
链路状态就是说明本路由器和哪些路由器相邻，以及该链路的“度量”或者说“代价“（表示费用、距离、时延带宽等等）。
③.只有链路状态发生变化时，路由器才对外用洪泛法发送此信息。
2、OSPF协议的原理：
所有路由器通过洪泛法发送链路状态信息，最终都能建立一个链路状态数据库（数据库实质上就是全网络拓扑结构图），每个路由器根据链路状态数据库中的数据，利用一定的算法（比如Dijkstra算法）构建一个到达每个网络的单源最短路径树，最后构造路由表； 
说明 	⑴、OSPF的链路状态数据库更新较快，收效也快。  
⑵、为使OSPF能适用于大规模网络，OSPF将一个AS划分成若干个更小范围，称作“域”。每一个域都有一个32位的区域标识符。一个区域不能太大，最好不超过200个路由器。  
划分区域的好处就是将洪泛法范围局限于一个区域内，而不是整个AS，这样可减少整个网络通信量。因而每个区域内的路由器仅知道本区域内完整网络拓扑。
⑶、为使每一区域能与本AS内其他区域通信，OSPF使用层次结构的区域划分。上层区域叫主干区域，标识符是0.0.0.0，主干区域的作用是用来联通其它在下层的区域。每个区域至少一个区域边界路由器。主干区域中的路由器叫主干路由器。主干路由器中还要有个路由器专门和其它AS交换路由信息，这样的路由器称作自治系统边界路由器。

3、OSPF的分组格式：
OSPF直接用IP数据报传送，不用UDP，OSPF数据报很短，可减少通信量，不必分片。  

⑴、OSPF的分组结构
①.版本当前版本号为2；
②.类型 5种类型中的一种；
③.分组长度包括OSPF首部在内的分组长度，以字节为单位；
④.区域标识符分组所属区域的标识符；
⑤.路由器标识符发送该分组的路由器接口的IP地址；
⑥.检验和检验分组中错；
⑦.鉴别类型 1口令，0不用；
⑧.鉴别鉴别类型为0时填入0，为1时填入8字符号令；
⑵、OSPF的五种分组类型：	
①.问候分组发现和维持邻站的可达性；
②.数据库描述分组向邻站给出自己链路状态数据库中所有链路状态项目的摘要信息；
③.链路状态请求分组请求对方发送某些链路状态项目的详细信息；
④.链路状态更新分组用洪泛法对全网更新链路状态；
⑤.链路状态确认分组对链路更新分组的确认；
相邻路由器每10秒交换一次问候分组，若40秒没有收到邻站问候分组，则认为邻站不可达，修改链路状态数据库，重新计算路由表。当路由器刚开始工作时，通过问候分组知晓邻站；
OSPF还规定每隔一段时间，如30分钟更新一次数据库
⑶、OSPF的基本操作：

### 4.5.4 外部网关协议 BGP

4.5.4、外部网关协议 BGP（Border Gateway Protocol）边界网关协议
⑴、外部网关协议和内部网关协议的区别：
BGP是不同于AS的路由器之间交换路由信息的协议，内部网关协议主要是设法使数据报在一个AS中尽可能有效的从源站传送到目的站，在AS内部不需要考虑其他方面策略。然而BGP使用的环境却不同，主要原因是： 
①.因特网规模太大，AS之间路由选择困难； 
②.AS之间路由选择必须考虑有关策略，因此路由选择协议应当允许使用多种路由选择策略，使这些策略是为了找出“较好的路径”，而不是最佳路径； 
⑵、BGP采用了路径向量路由选择协议：
配置BGP时，每一个AS的管理员要选择至少一个路由器作为该AS的“BGP发言人”。BGP发言人往往就是BGP边界路由器，但也可以不是。
①.BGP发言人要交换路由信息，要先建立TCP连接，然后在此连接上交换BGP会话。每一个BGP发言人除了必须运行BGP协议外，还必须运行其所在AS使用的内部网关协议；
   ②.BGP所交换的网络可达性信息就是要到达某个网络所要经过的一系列AS。各BGP发言人根据采用的策略从收到的路由信息中找出到达各AS的较好路由；
   ③.BGP路由表结构（目的网络前缀、下一跳路由、到达该目的网络所经过的AS序列）。因为BGP发言人收到其他BGP发言人发来的路径通知，要检查自己是否在路径序列中，如果在则不采用这个路径序列，以避免兜圈子。 
   ④.BGP邻站刚开始工作时交换整个BGP路由表。以后只需在发生变化时更新有变化的部分，以减少路由器处理开销及带宽
⑵、四种BGP报文：
①.OPEN（打开）报文与相邻BGP发言人建立关系，初始化通信；
②.UPDATE（更新）报文用来通告某一路由信息以及要撤销的多条路由；
③.KEEPALIVE（保活）报文周期性证实邻站连通性；
④.NOTIFICATION（通知）报文用来发送检测到的差错；
4.5.5、路由器的构成
路由器结构可划分为两个部分：路由选择部分+分组转发部分
⑴、路由部分也称控制部分，核心部件是路由选择处理机。它是根据所选定的路由协议构造出路由表。
⑵、分组转发部分由三个部分组成：交换结构、一组输入端口、一组输出端口。
交换结构根据转发表对分组进行处理

⑶、转发表和路由表的区别路由表根据网络拓扑计算，转发表则由路由表得到。转发表每行必须括到目的网络的输出端口及某些MAC信息，以后不加区分。 
总结	①.为什么既要MAC地址又要IP地址？
②.什么是网关？



## 如何配置路由？

通过上一节的内容，你应该已经知道，路由器就是一台网络设备，它有多张网卡。当一个入口的网络包送到路由器时，它会根据一个本地的转发信息库，来决定如何正确地转发流量。这个转发信息库通常被称为**路由表**。

一张路由表中会有多条路由规则。每一条规则至少包含这三项信息。

- 目的网络：这个包想去哪儿？
- 出口设备：将包从哪个口扔出去？
- 下一跳网关：下一个路由器的地址。

通过route命令和ip route命令都可以进行查询或者配置。

例如，我们设置ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0，就说明要去10.176.48.0/20这个目标网络，要从eth0端口出去，经过10.173.32.1。

上一节的例子中，网关上的路由策略就是按照这三项配置信息进行配置的。这种配置方式的一个核心思想是：**根据目的IP地址来配置路由**。

## 如何配置策略路由？

当然，在真实的复杂的网络环境中，除了可以根据目的ip地址配置路由外，还可以根据多个参数来配置路由，这就称为**策略路由**。

可以配置多个路由表，可以根据源IP地址、入口设备、TOS等选择路由表，然后在路由表中查找路由。这样可以使得来自不同来源的包走不同的路由。

例如，我们设置：

```
ip rule add from 192.168.1.0/24 table 10 
ip rule add from 192.168.2.0/24 table 20
```

表示从192.168.1.10/24这个网段来的，使用table 10中的路由表，而从192.168.2.0/24网段来的，使用table20的路由表。

在一条路由规则中，也可以走多条路径。例如，在下面的路由规则中：

```
ip route add default scope global nexthop via 100.100.100.1 weight 1 nexthop via 200.200.200.1 weight 2
```

下一跳有两个地方，分别是100.100.100.1和200.200.200.1，权重分别为1比2。

在什么情况下会用到如此复杂的配置呢？我来举一个现实中的例子。

我是房东，家里从运营商那儿拉了两根网线。这两根网线分别属于两个运行商。一个带宽大一些，一个带宽小一些。这个时候，我就不能买普通的家用路由器了，得买个高级点的，可以接两个外网的。

家里的网络呢，就是普通的家用网段192.168.1.x/24。家里有两个租户，分别把线连到路由器上。IP地址为192.168.1.101/24和192.168.1.102/24，网关都是192.168.1.1/24，网关在路由器上。

就像上一节说的一样，家里的网段是私有网段，出去的包需要NAT成公网的IP地址，因而路由器是一个NAT路由器。

两个运营商都要为这个网关配置一个公网的IP地址。如果你去查看你们家路由器里的网段，基本就是我图中画的样子。

![img](https://static001.geekbang.org/resource/image/03/69/03df39f76b60ac2c0a61b75a4dc25869.jpg)

运行商里面也有一个IP地址，在运营商网络里面的网关。不同的运营商方法不一样，有的是/32的，也即一个一对一连接。

例如，运营商1给路由器分配的地址是183.134.189.34/32，而运营商网络里面的网关是183.134.188.1/32。有的是/30的，也就是分了一个特别小的网段。运营商2给路由器分配的地址是60.190.27.190/30，运营商网络里面的网关是60.190.27.189/30。

根据这个网络拓扑图，可以将路由配置成这样：

```
$ ip route list table main 
60.190.27.189/30 dev eth3  proto kernel  scope link  src 60.190.27.190
183.134.188.1 dev eth2  proto kernel  scope link  src 183.134.189.34
192.168.1.0/24 dev eth1  proto kernel  scope link  src 192.168.1.1
127.0.0.0/8 dev lo  scope link
default via 183.134.188.1 dev eth2
```

当路由这样配置的时候，就告诉这个路由器如下的规则：

- 如果去运营商二，就走eth3；
- 如果去运营商一呢，就走eth2；
- 如果访问内网，就走eth1；
- 如果所有的规则都匹配不上，默认走运营商一，也即走快的网络。

但是问题来了，租户A不想多付钱，他说我就上上网页，从不看电影，凭什么收我同样贵的网费啊？没关系，咱有技术可以解决。

下面我添加一个Table，名字叫**chao**。

```
# echo 200 chao >> /etc/iproute2/rt_tables
```

添加一条规则：

```
# ip rule add from 192.168.1.101 table chao
# ip rule ls
0:    from all lookup local 
32765:    from 10.0.0.10 lookup chao
32766:    from all lookup main 
32767:    from all lookup default
```

设定规则为：从192.168.1.101来的包都查看个chao这个新的路由表。

在chao路由表中添加规则：

```
# ip route add default via 60.190.27.189 dev eth3 table chao
# ip route flush cache
```

默认的路由走慢的，谁让你不付钱。

上面说的都是静态的路由，一般来说网络环境简单的时候，在自己的可控范围之内，自己捣鼓还是可以的。但是有时候网络环境复杂并且多变，如果总是用静态路由，一旦网络结构发生变化，让网络管理员手工修改路由太复杂了，因而需要动态路由算法。

## 动态路由算法

使用动态路由路由器，可以根据路由协议算法生成动态路由表，随网络运行状况的变化而变化。那路由算法是什么样的呢？

我们可以想象唐僧西天取经，需要解决两大问题，一个是在每个国家如何找到正确的路，去换通关文牒、吃饭、休息；一个是在国家之间，野外行走的时候，如何找到正确的路、水源的问题。

![img](https://static001.geekbang.org/resource/image/6d/bb/6d1f0be048a04a08a40b16010f1180bb.jpg)

无论是一个国家内部，还是国家之间，我们都可以将复杂的路径，抽象为一种叫作图的数据结构。至于唐僧西行取经，肯定想走得路越少越好，道路越短越好，因而这就转化成为**如何在途中找到最短路径**的问题。

咱们在大学里面学习计算机网络与数据结构的时候，知道求最短路径常用的有两种方法，一种是Bellman-Ford算法，一种是Dijkstra算法。在计算机网络中基本也是用这两种方法计算的。

### 1.距离矢量路由算法

第一大类的算法称为**距离矢量路由**（**distance vector routing**）。它是基于Bellman-Ford算法的。

这种算法的基本思路是，每个路由器都保存一个路由表，包含多行，每行对应网络中的一个路由器，每一行包含两部分信息，一个是要到目标路由器，从那条线出去，另一个是到目标路由器的距离。

由此可以看出，每个路由器都是知道全局信息的。那这个信息如何更新呢？每个路由器都知道自己和邻居之间的距离，每过几秒，每个路由器都将自己所知的到达所有的路由器的距离告知邻居，每个路由器也能从邻居那里得到相似的信息。

每个路由器根据新收集的信息，计算和其他路由器的距离，比如自己的一个邻居距离目标路由器的距离是M，而自己距离邻居是x，则自己距离目标路由器是x+M。

这个算法比较简单，但是还是有问题。

**第一个问题就是好消息传得快，坏消息传得慢。**如果有个路由器加入了这个网络，它的邻居就能很快发现它，然后将消息广播出去。要不了多久，整个网络就都知道了。但是一旦一个路由器挂了，挂的消息是没有广播的。当每个路由器发现原来的道路到不了这个路由器的时候，感觉不到它已经挂了，而是试图通过其他的路径访问，直到试过了所有的路径，才发现这个路由器是真的挂了。

我再举个例子。

![img](https://static001.geekbang.org/resource/image/64/3f/641b14ede460105d15e23b077532013f.jpg)

原来的网络包括两个节点，B和C。A加入了网络，它的邻居B很快就发现A启动起来了。于是它将自己和A的距离设为1，同样C也发现A起来了，将自己和A的距离设置为2。但是如果A挂掉，情况就不妙了。B本来和A是邻居，发现连不上A了，但是C还是能够连上，只不过距离远了点，是2，于是将自己的距离设置为3。殊不知C的距离2其实是基于原来自己的距离为1计算出来的。C发现自己也连不上A，并且发现B设置为3，于是自己改成距离4。依次类推，数越来越大，直到超过一个阈值，我们才能判定A真的挂了。

这个道理有点像有人走丢了。当你突然发现找不到这个人了。于是你去学校问，是不是在他姨家呀？找到他姨家，他姨说，是不是在他舅舅家呀？他舅舅说，是不是在他姥姥家呀？他姥姥说，是不是在学校呀？总归要问一圈，或者是超过一定的时间，大家才会认为这个人的确走丢了。如果这个人其实只是去见了一个谁都不认识的网友去了，当这个人回来的时候，只要他随便见到其中的一个亲戚，这个亲戚就会拉着他到他的家长那里，说你赶紧回家，你妈都找你一天了。

**这种算法的第二个问题是，每次发送的时候，要发送整个全局路由表。**网络大了，谁也受不了，所以最早的路由协议RIP就是这个算法。它适用于小型网络（小于15跳）。当网络规模都小的时候，没有问题。现在一个数据中心内部路由器数目就很多，因而不适用了。

所以上面的两个问题，限制了距离矢量路由的网络规模。

### 2.链路状态路由算法

第二大类算法是**链路状态路由**（**link state routing**），基于Dijkstra算法。

这种算法的基本思路是：当一个路由器启动的时候，首先是发现邻居，向邻居say hello，邻居都回复。然后计算和邻居的距离，发送一个echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用Dijkstra算法，找到两点之间的最短路径。

不像距离距离矢量路由协议那样，更新时发送整个路由表。链路状态路由协议只广播更新的或改变的网络拓扑，这使得更新信息更小，节省了带宽和CPU利用率。而且一旦一个路由器挂了，它的邻居都会广播这个消息，可以使得坏消息迅速收敛。

## 动态路由协议

### 1.基于链路状态路由算法的OSPF

**OSPF**（**Open Shortest Path First**，**开放式最短路径优先**）就是这样一个基于链路状态路由协议，广泛应用在数据中心中的协议。由于主要用在数据中心内部，用于路由决策，因而称为**内部网关协议**（**Interior Gateway Protocol**，简称**IGP**）。

内部网关协议的重点就是找到最短的路径。在一个组织内部，路径最短往往最优。当然有时候OSPF可以发现多个最短的路径，可以在这多个路径中进行负载均衡，这常常被称为**等价路由**。

![img](https://static001.geekbang.org/resource/image/67/9b/6791cdd30119e78fcb3c350223d5049b.jpg)

这一点非常重要。有了等价路由，到一个地方去可以有相同的两个路线，可以分摊流量，还可以当一条路不通的时候，走另外一条路。这个在后面我们讲数据中心的网络的时候，一般应用的接入层会有负载均衡LVS。它可以和OSPF一起，实现高吞吐量的接入层设计。

有了内网的路由协议，在一个国家内，唐僧可以想怎么走怎么走了，两条路选一条也行。

### 2.基于距离矢量路由算法的BGP

但是外网的路由协议，也即国家之间的，又有所不同。我们称为**外网路由协议**（**Border Gateway Protocol**，简称**BGP**）。

在一个国家内部，有路当然选近的走。但是国家之间，不光远近的问题，还有政策的问题。例如，唐僧去西天取经，有的路近。但是路过的国家看不惯僧人，见了僧人就抓。例如灭法国，连光头都要抓。这样的情况即便路近，也最好绕远点走。

对于网络包同样，每个数据中心都设置自己的Policy。例如，哪些外部的IP可以让内部知晓，哪些内部的IP可以让外部知晓，哪些可以通过，哪些不能通过。这就好比，虽然从我家里到目的地最近，但是不能谁都能从我家走啊！

在网络世界，这一个个国家成为自治系统**AS**（Autonomous System）。自治系统分几种类型。

- Stub AS：对外只有一个连接。这类AS不会传输其他AS的包。例如，个人或者小公司的网络。
- Multihomed AS：可能有多个连接连到其他的AS，但是大多拒绝帮其他的AS传输包。例如一些大公司的网络。
- Transit AS：有多个连接连到其他的AS，并且可以帮助其他的AS传输包。例如主干网。

每个自治系统都有边界路由器，通过它和外面的世界建立联系。

![img](https://static001.geekbang.org/resource/image/c3/43/c3bce0ec298138d8e36e6ebf1375d843.jpg)

**BGP又分为两类，eBGP和iBGP。**自治系统间，边界路由器之间使用eBGP广播路由。内部网络也需要访问其他的自治系统。边界路由器如何将BGP学习到的路由导入到内部网络呢？就是通过运行iBGP，使得内部的路由器能够找到到达外网目的地的最好的边界路由器。

BGP协议使用的算法是**路径矢量路由协议**（path-vector protocol）。它是距离矢量路由协议的升级版。

前面说了距离矢量路由协议的缺点。其中一个是收敛慢。在BGP里面，除了下一跳hop之外，还包括了自治系统AS的路径，从而可以避免坏消息传的慢的问题，也即上面所描述的，B知道C原来能够到达A，是因为通过自己，一旦自己都到达不了A了，就不用假设C还能到达A了。

另外，在路径中将一个自治系统看成一个整体，不区分自治系统内部的路由器，这样自治系统的数目是非常有限的。就像大家都能记住出去玩，从中国出发先到韩国然后到日本，只要不计算细到具体哪一站，就算是发送全局信息，也是没有问题的。

## 小结

好了，这一节就到这里了，我来做个总结：

- 路由分静态路由和动态路由，静态路由可以配置复杂的策略路由，控制转发策略；
- 动态路由主流算法有两种，距离矢量算法和链路状态算法。基于两种算法产生两种协议，BGP协议和OSPF协议。

最后，再给你留两个思考题：

1. 路由协议要在路由器之间交换信息，这些信息的交换还需要走路由吗？不是死锁了吗？
2. 路由器之间信息的交换使用什么协议呢？报文格式是什么样呢？





rip是udp协议，ospf直接发ip包。而bgp使用tcp协议，路由器之间会建立tcp连接，每60s发送一次keep-alive消息。

OSPF是直接基于IP协议发送的，而且OSPF的包都是发给邻居的，也即只有一跳，不会中间经过路由设备。BGP是基于TCP协议的，在BGP peer之间交换信息。



---



多线BGP机房是怎么回事儿？

很多主机商售卖主机时会强调自己时BGP机房多线接入，虽然只有一个ip，往往各个运营商下访问延迟都很低，这个BGP和文章里的BGP时一回事吗，他们怎么做到的

BGP主要用于互联网AS自治系统之间的互联，BGP的最主要功能在于**控制路由的传播**和**选择最好的路由**。各大运营商都具有AS号，全国各大网络运营商多数都是通过BGP协议与自身的AS来实现多线互联的。

使用此方案来实现多线路互联，IDC需要在CNNIC（中国互联网信息中心）或APNIC（亚太网络信息中心）申请自己的IP地址段和AS号，然后通过BGP协议将此段IP地址广播到其它的网络运营商的网络中。

使用BGP协议互联后，网络运营商的所有骨干路由设备将会判断到IDC机房IP段的最佳路由，以保证不同网络运营商用户的高速访问。

----

BGP基于TCP，OSPF基于UDP

老师您好，运营商1和eth2的连接是一对一的是什么意思？/32 的话，子网掩码是255.255.255.255，eth2和运营商并不在一个网络，是怎么通信的？

2018-06-06 09:17

作者回复

p2p



\#提纲
\1. 静态路由实现原理
\- 3项路由：目标ip，出口ip，下一跳网关IP
\- 策略路由：多路由表/多路径
\2. 动态路由实现原理
\- 距离矢量路由算法：BGP
\- 链路状态路由算法：OSPF



老师你好，文章这部分
32765: from.10.0.0.10 lookup chao
中10.0.0.10的地址是不是应改为租户A的地址:192.168.1.101

2018-09-23 10:27

作者回复

是的，谢谢指正



- 请问下老师，都说lastmile是网络链路中延迟最大的，也是是业界最难解决的问题，能解释下lastmile为什么会有比较大的延迟吗？

  2018-06-06 23:35

- 

  赵强强

  老师，距离矢量路由算法避免不了循环更新路由吗？比如上面举例B和C，当B到不了A时，此时B把距离变更为不可达，当C向B发送路由信息表时，B应该可以发现C到A的下一跳是自己，应该不更新自己就好了，并告诉C路由失效，就可以避免无用的循环更新。请老师解答一下。

  2018-06-06 11:12

  作者回复

  因为没有下一跳的信息，如果有这个相当于记录了路径了

  2018-06-06 15:53





BGP用到的路径矢量路由协议是距离矢量路由协议的升级版，这个不太理解。老师有没有推荐的资料呢？

2018-11-20 10:38

作者回复

就是保存了路径，计算机网络 书籍里面都有

2018-11-20 17:12





- 请教下，在开篇简单路由器是有多个网卡的，记得路由器网络设置里分为lan口和wlan口设置，这两口的mac地址不同，说明lan和wlan是两个网卡，但是路由器是有多个lan口的，发现lan口的mac地址是统一的，这是不是说明lan是一个网卡，且有多个网口;wlan是一个网卡?还有就是lan和wlan是两个网卡，他们之间的网络包传递是怎么实现的？谢谢！

  2018-06-07 07:06

  作者回复

  是的，家用路由器虽然多个口，但是其实像我们示意图里面一样，是一个地址加交换机的形式。wlan和lan要过路由

  2018-06-07 13:21

- 

  Zend

  在公司内网的测试环境 就遇到 多个部署微服务的物理机网段不一样，但http服务走浏览器访问能通，但机器之间ping不通，这是为什么啊

  2018-06-06 20:44

- 

  docker

  顶

  2018-06-06 07:29

- 

  张盼盼

  第一个问题，应该是使用广播模式吧，这个就可以避免鸡生蛋生鸡的问题
  第二个问题，应该是使用udp协议发广播包

  2018-12-13 14:08

- 

  西部世界

  一、求最短距离的两个常见算法：
  1.1 Bellman-Ford：是求含负权图的单源最短路径的一种算法，效率较低，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在n-1次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。
  1.2 Dijkstra：是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。
  二、路由器的路由算法：
  2.1 距离矢量路由算法：每个路由器维护一张路由表，即一个矢量，它以网络中的每个路由器为索引，表中列出了当前已知的路由器到每个目标路由器的最佳距离，以及所使用的线路。通过在邻居之间相互交换信息，路由器不断地更新他们的内部路由表。（该算法基于Bellman-Ford）
  2.2 链路状态路由算法：是要求网络中所有参与链路状态路由协议的路由器都掌握网络的全部拓扑结构信息，并记录在路由数据库中。链路状态算法中路由数据库实质上是一个网络结构的拓扑图，该拓扑图由一个节点的集合和一个边的集合构成。在网络拓扑图中，结点代表网络中路由器，边代表路由器之间的物理链路。在网络拓扑结构图中，每一条链路上可以附加不同的属性，例如链路的状态、距离或费用等。如果每一个路由器所保存的网络拓扑结构图都是一致的，那么个路由器生成的路由表也是最佳的，不存在错误路由或循环路由。（该算法基于Dijkstra）。
  三：基于两个路由算法而衍生出来的两个路由协议：
  3.1基于距离矢量路由算法的BGP协议：???
  3.2基于链路状态路由算法的OSPF协议：???
  小结：
  1.距离矢量路由算法存在环回路由，慢收敛，无穷计算，扩展性差等，存在的问题：环回路由，慢收敛，无穷计算，扩展性差，仅适用于小网络场景。
  2.链路状态路由算法：链路状态算法具有更快的收敛速度,具有更好的功能扩展能力.还提供了更好的在规模上的可升级性，缺点：每个路由器需要有较大的存储空间，用以存储所收到的每一个节点的链路状态分组；计算工作量大，每次都必须计算最短路径。
  ===============================================================
  自我查阅总结：路由协议应该比老师讲的要深的深得多。 并且是基于和结合很多另外的一些知识点而形成的一整套路由方案的解决课题。要深入理解和学习的话，还要学习的太多， 老师这个讲的只是一个敲门砖。

  2018-12-04 15:53
