### 3.2 使用点对点信道的数据链路层

### 3.2.1 点对点信道数据链路层通信主要步骤：

1. 发送方A数据链路层将网络层交下来的IP数据报添加首部和尾部**封装成帧**
2. 发送方A将封装好的帧发送给结点B的数据链路层
3. 接收方B收到的帧无措，则从帧中提取出IP数据报转给网络层；若有错，则丢弃该帧（如下图所示）

![](/assets/link layer P2P step.png)

### 3.2.2 数据链路层的三个基本问题

1. 封装成帧：在一段数据的前后分别添加首部和尾部，构成一个帧  
   1. 帧的首部和尾部一个重要作用是进行帧定界；

   1. 帧首和帧尾还包括许多必要的控制信息；

   2. 为提高帧传输效率，应使帧的数据部分尽可能大；

   3. 每一种链路层协议都规定了数据部分长度上限 --&gt; **MTU**；

   帧长 = 帧首部长 + 数据部分长 + 帧尾部长

   | SOH（帧开始符） | 帧中数据部分 | EOT（帧结束符） |
   | :--- | :--- | :--- |

2. 透明传输  
   当数据部分是非ASCⅡ文件时，若数据某字节恰好是SOH或EOT这种控制字符时，数据链路层就会错误地处理帧，这就是“不透明传输”，显然：如果数据部分某字节是SOH或EOT字符时也能正确传输，我们称之为**透明传输**；

   实现透明传输的方法è插入转义字符**ESC**（**00011011**）：

   **⑴、**若数据部分出现EOT或SOH时，就在这个EOT和SOH前插入ESC；接收方在送交网络层之前将这个ESC删除。

   **⑵、**用ESC ESC表示ESC。

   上述方法称之为“**字节填充**”或“**字符填充**”

3. 差错检测

   1. 差错产生的原因和差错类型

      1. 当数据从信源出发经过通信信道时，由于通信信道存在着噪声，因此数据信号通过通信信道到达信宿时，接收到的信号必然是数据信号与信号电平的叠加；

      2. 接收方对叠加后的信号进行判断，以确定0、1值。如果判断错误，则会产生数据传输错误；

      3. 噪声分两类：热噪声、冲击噪声；

         **①**热噪声是由传输介质导体的分子热运动产生的。时刻存在，由它引起的噪声是随机的，引起的差错是随机差错；

         **②**冲击噪声引起突发错；

      4. **误码率：**二进制比特在数据传输系统中被传错的概率；

   2. CRC循环冗余编码工作原理

      1. 将要发送的数据比特序列当作一个多项式f\(x\)的系数，在发送端用收发双方预先约定的生成多项式G\(x\)去除，求出一个余数多项式。将余数多项式加到数据多项式后发送到接收端；

      2. 接收端用同样的G\(x\)去除收到的$$f^{1}(x)$$，得到余数多项式。如果得到的余数多项式与接收到的余数多项式相同，表示传输无错。否则有错，发送方重传；

      3. **注意：** G\(x\)由协议来规定，其结构及检错效果是经过严格数学分析与实验后确定；

   3. CRC具体做法

      1. 发送方将要发送的数据分组，假定每组K个比特，其多项式为M\(x\),生成多项式为r阶多项式G\(x\)，则在原始数据后加N个0形成$$x^{r}*M(x)$$_，用_$$x^{r}*M(x)$$按照模2除法除G\(x\)得到余项，把余项放在原始数据尾部作为真正的发送数据；CRC运算就是在数据**M**后添加**N**位冗余码，供差错检测用N，然后将数据与冗余码一起发送出去，共（K+N）位。

      2. 冗余码求法如下：将数据**M**乘以$$2^N$$，相当于在**M**后加**N**个0.用事先商量好的长度为\(N+1\)位的**除数P**除，得到余数**R**，然后把**R**放在数据**M**后面，具体如下：

         【**例题3.2**】**发送数据M**=1101011011（K=10），双方约定生成多项式为**10011**，即：G\(x\)=$$x^4$$+x+1，**N=4**；

         ![](/assets/CRC.png)

         故实际发送为**110011011**1110**\(在数据后面添加的冗余码**1110**称为**帧检验序列**FCS**\)；

         接收方将受到的每一帧用同样的**除数**P除，检查余数，若余数为0则无错，否则有错，余数不为0的概率极小，一般而言传输出错而余数为0的概率极小。

   4. 特别注意以下问题

      1. 循环冗余检验CRC和帧检验序列 FCS并不等同：

         CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码；

         FCS 可以用 CRC 这种方法得出，但也可以用其它方法得出；

      2. **仅用CRC差错检测技术只能做到**无差错接受**\[即：凡是接收端数据链路层接受的帧都没有传输差错（有差错的帧就丢弃而不接受）；要做到“可靠传输”（即发送什么就能收到什么，解决了帧丢失、帧重复、帧失序等传输差错）就必须再加上**确认和重传机制\*\*。

      3. 因特网的**数据链路层不使用确认和重传机制**（因为代价高），由运输层TCP协议实现可靠传输。



